/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MoneyOutsApiService MoneyOutsApi service
type MoneyOutsApiService service

type ApiMoneyOutsCancelPutRequest struct {
	ctx context.Context
	ApiService *MoneyOutsApiService
	transactionid int64
	authorization *string
	pSUIPAddress *string
	parameters *CancelMoneyOutInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyOutsCancelPutRequest) Authorization(authorization string) ApiMoneyOutsCancelPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyOutsCancelPutRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyOutsCancelPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyOutsCancelPutRequest) Parameters(parameters CancelMoneyOutInput) ApiMoneyOutsCancelPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyOutsCancelPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyOutsCancelPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyOutsCancelPutRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyOutsCancelPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyOutsCancelPutRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyOutsCancelPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsCancelPutRequest) AuthorizationBasicFromProvider() ApiMoneyOutsCancelPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsCancelPutRequest) AuthorizationBearerFromProvider() ApiMoneyOutsCancelPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyOutsCancelPutRequest) Execute() (*CancelMoneyOutOutput, *http.Response, error) {
	return r.ApiService.MoneyOutsCancelPutExecute(r)
}

/*
MoneyOutsCancelPut Money-Out Cancellation

The cancel call lets you cancel a Money-Out/SDD.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionid
 @return ApiMoneyOutsCancelPutRequest
*/
func (a *MoneyOutsApiService) MoneyOutsCancelPut(ctx context.Context, transactionid int64) ApiMoneyOutsCancelPutRequest {
	return ApiMoneyOutsCancelPutRequest{
		ApiService: a,
		ctx: ctx,
		transactionid: transactionid,
	}
}

// Execute executes the request
//  @return CancelMoneyOutOutput
func (a *MoneyOutsApiService) MoneyOutsCancelPutExecute(r ApiMoneyOutsCancelPutRequest) (*CancelMoneyOutOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelMoneyOutOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyOutsApiService.MoneyOutsCancelPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyouts/{transactionid}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionid"+"}", url.PathEscape(parameterToString(r.transactionid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(CancelMoneyOutInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyOutsIbanExtendedPostRequest struct {
	ctx context.Context
	ApiService *MoneyOutsApiService
	authorization *string
	pSUIPAddress *string
	parameters *RegisterIBANExtendedInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyOutsIbanExtendedPostRequest) Authorization(authorization string) ApiMoneyOutsIbanExtendedPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyOutsIbanExtendedPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyOutsIbanExtendedPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyOutsIbanExtendedPostRequest) Parameters(parameters RegisterIBANExtendedInput) ApiMoneyOutsIbanExtendedPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyOutsIbanExtendedPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyOutsIbanExtendedPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyOutsIbanExtendedPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyOutsIbanExtendedPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyOutsIbanExtendedPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyOutsIbanExtendedPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanExtendedPostRequest) AuthorizationBasicFromProvider() ApiMoneyOutsIbanExtendedPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanExtendedPostRequest) AuthorizationBearerFromProvider() ApiMoneyOutsIbanExtendedPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyOutsIbanExtendedPostRequest) Execute() (*RegisterIBANExtendedOutput, *http.Response, error) {
	return r.ApiService.MoneyOutsIbanExtendedPostExecute(r)
}

/*
MoneyOutsIbanExtendedPost Add Bank Account to a Payment Account for Money-Outs

You are required to register your client's bank account details in order to send Money-Out from a Lemonway payment account.  
With this method, our system links other bank formats to a payment account.  

**Important:** If your client bank account details are in IBAN format this call.  

- Client bank account details are **only** required for money-outs.  
- When you link a new bank account (IBAN format or other ones), the previous ones are still active.  
- Please use [IbanUnregisterPut](https://documentation.lemonway.com/reference/moneyouts_ibanunregisterput) method to deactivate a bank account from a payment account. 
- If you wish to use only one bank account per payment account, please contact support.  
            
Depending on bank country code selected or when a USD environment is concerned, 3 fields may be required:  
- bankBranchRoutingCode  
- bankName  
- bankBranchAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyOutsIbanExtendedPostRequest
*/
func (a *MoneyOutsApiService) MoneyOutsIbanExtendedPost(ctx context.Context) ApiMoneyOutsIbanExtendedPostRequest {
	return ApiMoneyOutsIbanExtendedPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterIBANExtendedOutput
func (a *MoneyOutsApiService) MoneyOutsIbanExtendedPostExecute(r ApiMoneyOutsIbanExtendedPostRequest) (*RegisterIBANExtendedOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterIBANExtendedOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyOutsApiService.MoneyOutsIbanExtendedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyouts/iban/extended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(RegisterIBANExtendedInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyOutsIbanGetRequest struct {
	ctx context.Context
	ApiService *MoneyOutsApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyOutsIbanGetRequest) Authorization(authorization string) ApiMoneyOutsIbanGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyOutsIbanGetRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyOutsIbanGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyOutsIbanGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyOutsIbanGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyOutsIbanGetRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyOutsIbanGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyOutsIbanGetRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyOutsIbanGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanGetRequest) AuthorizationBasicFromProvider() ApiMoneyOutsIbanGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanGetRequest) AuthorizationBearerFromProvider() ApiMoneyOutsIbanGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyOutsIbanGetRequest) Execute() (*AccountIbansOutput, *http.Response, error) {
	return r.ApiService.MoneyOutsIbanGetExecute(r)
}

/*
MoneyOutsIbanGet Get the IBAN Associated with a Payment Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiMoneyOutsIbanGetRequest
*/
func (a *MoneyOutsApiService) MoneyOutsIbanGet(ctx context.Context, accountid string) ApiMoneyOutsIbanGetRequest {
	return ApiMoneyOutsIbanGetRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return AccountIbansOutput
func (a *MoneyOutsApiService) MoneyOutsIbanGetExecute(r ApiMoneyOutsIbanGetRequest) (*AccountIbansOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountIbansOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyOutsApiService.MoneyOutsIbanGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyouts/{accountid}/iban"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyOutsIbanPostRequest struct {
	ctx context.Context
	ApiService *MoneyOutsApiService
	authorization *string
	pSUIPAddress *string
	parameters *RegisterIBANInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyOutsIbanPostRequest) Authorization(authorization string) ApiMoneyOutsIbanPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyOutsIbanPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyOutsIbanPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyOutsIbanPostRequest) Parameters(parameters RegisterIBANInput) ApiMoneyOutsIbanPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyOutsIbanPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyOutsIbanPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyOutsIbanPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyOutsIbanPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyOutsIbanPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyOutsIbanPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanPostRequest) AuthorizationBasicFromProvider() ApiMoneyOutsIbanPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanPostRequest) AuthorizationBearerFromProvider() ApiMoneyOutsIbanPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyOutsIbanPostRequest) Execute() (*RegisterIBANOutput, *http.Response, error) {
	return r.ApiService.MoneyOutsIbanPostExecute(r)
}

/*
MoneyOutsIbanPost Add an IBAN to a Payment Account for Money-Outs

To send Money-Out from the Lemonway payment account to the bank account of your Clients, you need to register their bank account details. This method lets our system to link an IBAN to a payment account.  
- Bank account details are only needed for Money-Outs, not for Money-Ins or P2P.  
- When you link a new bank account (IBAN format or other ones), the previous details are still active.  
- Use [IbanUnregisterPut](https://documentation.lemonway.com/reference/moneyouts_ibanunregisterput) call to deactivate a bank account from a payment account.  
- If you wish to use only one bank account per payment account, please contact support.  
- An integrated algorithm will validate your IBAN.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyOutsIbanPostRequest
*/
func (a *MoneyOutsApiService) MoneyOutsIbanPost(ctx context.Context) ApiMoneyOutsIbanPostRequest {
	return ApiMoneyOutsIbanPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterIBANOutput
func (a *MoneyOutsApiService) MoneyOutsIbanPostExecute(r ApiMoneyOutsIbanPostRequest) (*RegisterIBANOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterIBANOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyOutsApiService.MoneyOutsIbanPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyouts/iban"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(RegisterIBANInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyOutsIbanUnregisterPutRequest struct {
	ctx context.Context
	ApiService *MoneyOutsApiService
	ibanId int64
	authorization *string
	pSUIPAddress *string
	parameters *UnregisterIBANInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyOutsIbanUnregisterPutRequest) Authorization(authorization string) ApiMoneyOutsIbanUnregisterPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyOutsIbanUnregisterPutRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyOutsIbanUnregisterPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyOutsIbanUnregisterPutRequest) Parameters(parameters UnregisterIBANInput) ApiMoneyOutsIbanUnregisterPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyOutsIbanUnregisterPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyOutsIbanUnregisterPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyOutsIbanUnregisterPutRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyOutsIbanUnregisterPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyOutsIbanUnregisterPutRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyOutsIbanUnregisterPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanUnregisterPutRequest) AuthorizationBasicFromProvider() ApiMoneyOutsIbanUnregisterPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsIbanUnregisterPutRequest) AuthorizationBearerFromProvider() ApiMoneyOutsIbanUnregisterPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyOutsIbanUnregisterPutRequest) Execute() (*UnregisterIBANOutput, *http.Response, error) {
	return r.ApiService.MoneyOutsIbanUnregisterPutExecute(r)
}

/*
MoneyOutsIbanUnregisterPut Disable Bank Information (IBAN) from a Payment Account

The <b>UnregisterIBAN</b> method enables you to disable an IBAN from a Payment Account. As a reminder a bank account number (IBAN) is needed to process Money-Out. An IBAN is not needed to perform Money-In on a Payment Account or Peer to Peer transfers between Payments Accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ibanId
 @return ApiMoneyOutsIbanUnregisterPutRequest
*/
func (a *MoneyOutsApiService) MoneyOutsIbanUnregisterPut(ctx context.Context, ibanId int64) ApiMoneyOutsIbanUnregisterPutRequest {
	return ApiMoneyOutsIbanUnregisterPutRequest{
		ApiService: a,
		ctx: ctx,
		ibanId: ibanId,
	}
}

// Execute executes the request
//  @return UnregisterIBANOutput
func (a *MoneyOutsApiService) MoneyOutsIbanUnregisterPutExecute(r ApiMoneyOutsIbanUnregisterPutRequest) (*UnregisterIBANOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnregisterIBANOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyOutsApiService.MoneyOutsIbanUnregisterPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyouts/iban/{IbanId}/unregister"
	localVarPath = strings.Replace(localVarPath, "{"+"IbanId"+"}", url.PathEscape(parameterToString(r.ibanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(UnregisterIBANInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyOutsMoneyOutGetRequest struct {
	ctx context.Context
	ApiService *MoneyOutsApiService
	authorization *string
	pSUIPAddress *string
	transactionid *int64
	transactionComment *string
	reference *string
	page *int32
	limit *int32
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyOutsMoneyOutGetRequest) Authorization(authorization string) ApiMoneyOutsMoneyOutGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyOutsMoneyOutGetRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyOutsMoneyOutGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Money-Out ID
func (r ApiMoneyOutsMoneyOutGetRequest) Transactionid(transactionid int64) ApiMoneyOutsMoneyOutGetRequest {
	r.transactionid = &transactionid
	return r
}

// Money-Out Comment
func (r ApiMoneyOutsMoneyOutGetRequest) TransactionComment(transactionComment string) ApiMoneyOutsMoneyOutGetRequest {
	r.transactionComment = &transactionComment
	return r
}

// Unique ID Generated by your Server
func (r ApiMoneyOutsMoneyOutGetRequest) Reference(reference string) ApiMoneyOutsMoneyOutGetRequest {
	r.reference = &reference
	return r
}

// Index start from 1, let null to get all
func (r ApiMoneyOutsMoneyOutGetRequest) Page(page int32) ApiMoneyOutsMoneyOutGetRequest {
	r.page = &page
	return r
}

// Default 20, let it null if no pagination
func (r ApiMoneyOutsMoneyOutGetRequest) Limit(limit int32) ApiMoneyOutsMoneyOutGetRequest {
	r.limit = &limit
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyOutsMoneyOutGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyOutsMoneyOutGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyOutsMoneyOutGetRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyOutsMoneyOutGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyOutsMoneyOutGetRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyOutsMoneyOutGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsMoneyOutGetRequest) AuthorizationBasicFromProvider() ApiMoneyOutsMoneyOutGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsMoneyOutGetRequest) AuthorizationBearerFromProvider() ApiMoneyOutsMoneyOutGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyOutsMoneyOutGetRequest) Execute() (*GetMoneyOutTransDetailsOutput, *http.Response, error) {
	return r.ApiService.MoneyOutsMoneyOutGetExecute(r)
}

/*
MoneyOutsMoneyOutGet Search for a Money-Out

Use this call to get and check all Money-Out information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyOutsMoneyOutGetRequest
*/
func (a *MoneyOutsApiService) MoneyOutsMoneyOutGet(ctx context.Context) ApiMoneyOutsMoneyOutGetRequest {
	return ApiMoneyOutsMoneyOutGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMoneyOutTransDetailsOutput
func (a *MoneyOutsApiService) MoneyOutsMoneyOutGetExecute(r ApiMoneyOutsMoneyOutGetRequest) (*GetMoneyOutTransDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMoneyOutTransDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyOutsApiService.MoneyOutsMoneyOutGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	if r.transactionid != nil {
		localVarQueryParams.Add("transactionid", parameterToString(*r.transactionid, ""))
	}
	if r.transactionComment != nil {
		localVarQueryParams.Add("transactionComment", parameterToString(*r.transactionComment, ""))
	}
	if r.reference != nil {
		localVarQueryParams.Add("reference", parameterToString(*r.reference, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyOutsMoneyOutPostRequest struct {
	ctx context.Context
	ApiService *MoneyOutsApiService
	authorization *string
	pSUIPAddress *string
	parameters *MoneyOutInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyOutsMoneyOutPostRequest) Authorization(authorization string) ApiMoneyOutsMoneyOutPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyOutsMoneyOutPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyOutsMoneyOutPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyOutsMoneyOutPostRequest) Parameters(parameters MoneyOutInput) ApiMoneyOutsMoneyOutPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyOutsMoneyOutPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyOutsMoneyOutPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyOutsMoneyOutPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyOutsMoneyOutPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyOutsMoneyOutPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyOutsMoneyOutPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsMoneyOutPostRequest) AuthorizationBasicFromProvider() ApiMoneyOutsMoneyOutPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyOutsMoneyOutPostRequest) AuthorizationBearerFromProvider() ApiMoneyOutsMoneyOutPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyOutsMoneyOutPostRequest) Execute() (*MoneyOutOutput, *http.Response, error) {
	return r.ApiService.MoneyOutsMoneyOutPostExecute(r)
}

/*
MoneyOutsMoneyOutPost External Fund Transfer from a Payment Account to a Bank Account

How does it work?
Select an IBAN if multiple IBAN exist for the wallet. Select an amount, not greater than the balance of the wallet. Call the moneout method, and the system performs the fund transfer to the IBAN if everything is clear, or returns an error message.
<ul><li>The payment account is debited immediately and the money is then received by the owner, in their bank account between 1 to 3 days after, depending on the interbanking system and on the banks (SEPA is faster).</li><li>You can ask us to configure your platform so that your comment is included in the bank transfer message so your customer will see it on the bank statement.</li><li><ul><li>The full message will be in the following format "XXXX-YYYY ZZZZ", where : </li><li>XXXX is the name of your environment</li><li>YYYY is the ID of the Money-Out operation as you see it in the Dashboard</li><li>ZZZZ is your comment.</li></ul></li><li>The full message cannot be longer than 35 characters (if longer, it will be cut), and only alphanumeric characters will be allowed(other characters will be replaced by spaces before it's sent to the bank).</li></ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyOutsMoneyOutPostRequest
*/
func (a *MoneyOutsApiService) MoneyOutsMoneyOutPost(ctx context.Context) ApiMoneyOutsMoneyOutPostRequest {
	return ApiMoneyOutsMoneyOutPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyOutOutput
func (a *MoneyOutsApiService) MoneyOutsMoneyOutPostExecute(r ApiMoneyOutsMoneyOutPostRequest) (*MoneyOutOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyOutOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyOutsApiService.MoneyOutsMoneyOutPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyOutInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
