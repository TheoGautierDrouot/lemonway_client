/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MoneyInsVirtualIBANApiService MoneyInsVirtualIBANApi service
type MoneyInsVirtualIBANApiService service

type ApiMoneyInsBankwireIbanCountGetRequest struct {
	ctx context.Context
	ApiService *MoneyInsVirtualIBANApiService
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsBankwireIbanCountGetRequest) Authorization(authorization string) ApiMoneyInsBankwireIbanCountGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsBankwireIbanCountGetRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsBankwireIbanCountGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsBankwireIbanCountGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsBankwireIbanCountGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsBankwireIbanCountGetRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsBankwireIbanCountGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsBankwireIbanCountGetRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsBankwireIbanCountGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsBankwireIbanCountGetRequest) AuthorizationBasicFromProvider() ApiMoneyInsBankwireIbanCountGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsBankwireIbanCountGetRequest) AuthorizationBearerFromProvider() ApiMoneyInsBankwireIbanCountGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsBankwireIbanCountGetRequest) Execute() (*GetVibanCountOutput, *http.Response, error) {
	return r.ApiService.MoneyInsBankwireIbanCountGetExecute(r)
}

/*
MoneyInsBankwireIbanCountGet Get VIBANs count

This endpoint enables you to retrieve the VIBAN count, the remaining VIBAN count and the max VIBAN thresholds.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsBankwireIbanCountGetRequest
*/
func (a *MoneyInsVirtualIBANApiService) MoneyInsBankwireIbanCountGet(ctx context.Context) ApiMoneyInsBankwireIbanCountGetRequest {
	return ApiMoneyInsBankwireIbanCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetVibanCountOutput
func (a *MoneyInsVirtualIBANApiService) MoneyInsBankwireIbanCountGetExecute(r ApiMoneyInsBankwireIbanCountGetRequest) (*GetVibanCountOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVibanCountOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsVirtualIBANApiService.MoneyInsBankwireIbanCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/bankwire/iban/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsBankwireIbanCreatePostRequest struct {
	ctx context.Context
	ApiService *MoneyInsVirtualIBANApiService
	authorization *string
	pSUIPAddress *string
	parameters *CreateIBANInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsBankwireIbanCreatePostRequest) Authorization(authorization string) ApiMoneyInsBankwireIbanCreatePostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsBankwireIbanCreatePostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsBankwireIbanCreatePostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsBankwireIbanCreatePostRequest) Parameters(parameters CreateIBANInput) ApiMoneyInsBankwireIbanCreatePostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsBankwireIbanCreatePostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsBankwireIbanCreatePostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsBankwireIbanCreatePostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsBankwireIbanCreatePostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsBankwireIbanCreatePostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsBankwireIbanCreatePostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsBankwireIbanCreatePostRequest) AuthorizationBasicFromProvider() ApiMoneyInsBankwireIbanCreatePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsBankwireIbanCreatePostRequest) AuthorizationBearerFromProvider() ApiMoneyInsBankwireIbanCreatePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsBankwireIbanCreatePostRequest) Execute() (*CreateIBANOutput, *http.Response, error) {
	return r.ApiService.MoneyInsBankwireIbanCreatePostExecute(r)
}

/*
MoneyInsBankwireIbanCreatePost Create Dedicated Virtual IBANs

This feature enables you to create dedicated (virtual) IBANs. These IBANs are linked to a dedicated payment account and give the possibility to you to receive wire transfers directly to these accounts. The payment schema must be validated prior with Lemonway. This method should be called once you are certain a payment will be received. We advise against associating an IBAN to a payment account preventively. Please contact your account manager to have this function activated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsBankwireIbanCreatePostRequest
*/
func (a *MoneyInsVirtualIBANApiService) MoneyInsBankwireIbanCreatePost(ctx context.Context) ApiMoneyInsBankwireIbanCreatePostRequest {
	return ApiMoneyInsBankwireIbanCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateIBANOutput
func (a *MoneyInsVirtualIBANApiService) MoneyInsBankwireIbanCreatePostExecute(r ApiMoneyInsBankwireIbanCreatePostRequest) (*CreateIBANOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateIBANOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsVirtualIBANApiService.MoneyInsBankwireIbanCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/bankwire/iban/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(CreateIBANInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsBankwireIbanDisablePostRequest struct {
	ctx context.Context
	ApiService *MoneyInsVirtualIBANApiService
	ibanid int64
	authorization *string
	pSUIPAddress *string
	parameters *DisableIBANInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsBankwireIbanDisablePostRequest) Authorization(authorization string) ApiMoneyInsBankwireIbanDisablePostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsBankwireIbanDisablePostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsBankwireIbanDisablePostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsBankwireIbanDisablePostRequest) Parameters(parameters DisableIBANInput) ApiMoneyInsBankwireIbanDisablePostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsBankwireIbanDisablePostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsBankwireIbanDisablePostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsBankwireIbanDisablePostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsBankwireIbanDisablePostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsBankwireIbanDisablePostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsBankwireIbanDisablePostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsBankwireIbanDisablePostRequest) AuthorizationBasicFromProvider() ApiMoneyInsBankwireIbanDisablePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsBankwireIbanDisablePostRequest) AuthorizationBearerFromProvider() ApiMoneyInsBankwireIbanDisablePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsBankwireIbanDisablePostRequest) Execute() (*DisableIBANOutput, *http.Response, error) {
	return r.ApiService.MoneyInsBankwireIbanDisablePostExecute(r)
}

/*
MoneyInsBankwireIbanDisablePost Disable a Dedicated Virtual IBAN

This functionality enables you to disable dedicated IBANs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ibanid
 @return ApiMoneyInsBankwireIbanDisablePostRequest
*/
func (a *MoneyInsVirtualIBANApiService) MoneyInsBankwireIbanDisablePost(ctx context.Context, ibanid int64) ApiMoneyInsBankwireIbanDisablePostRequest {
	return ApiMoneyInsBankwireIbanDisablePostRequest{
		ApiService: a,
		ctx: ctx,
		ibanid: ibanid,
	}
}

// Execute executes the request
//  @return DisableIBANOutput
func (a *MoneyInsVirtualIBANApiService) MoneyInsBankwireIbanDisablePostExecute(r ApiMoneyInsBankwireIbanDisablePostRequest) (*DisableIBANOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisableIBANOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsVirtualIBANApiService.MoneyInsBankwireIbanDisablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/bankwire/iban/{ibanid}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"ibanid"+"}", url.PathEscape(parameterToString(r.ibanid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(DisableIBANInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
