/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MoneyInsCardsApiService MoneyInsCardsApi service
type MoneyInsCardsApiService service

type ApiMoneyInsCardsCancelPutRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	transactionid int64
	authorization *string
	pSUIPAddress *string
	parameters *CancelMoneyInInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardsCancelPutRequest) Authorization(authorization string) ApiMoneyInsCardsCancelPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardsCancelPutRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardsCancelPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardsCancelPutRequest) Parameters(parameters CancelMoneyInInput) ApiMoneyInsCardsCancelPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardsCancelPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardsCancelPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardsCancelPutRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardsCancelPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardsCancelPutRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardsCancelPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardsCancelPutRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardsCancelPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardsCancelPutRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardsCancelPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardsCancelPutRequest) Execute() (*CancelMoneyInOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCancelPutExecute(r)
}

/*
MoneyInsCancelPut Cancel a Money-In

With the PUT /moneyins/{transactionid}/cancel method, you can cancel a pre-authorization / SEPA Direct Debit (SDD) request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionid
 @return ApiMoneyInsCardsCancelPutRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCancelPut(ctx context.Context, transactionid int64) ApiMoneyInsCardsCancelPutRequest {
	return ApiMoneyInsCardsCancelPutRequest{
		ApiService: a,
		ctx: ctx,
		transactionid: transactionid,
	}
}

// Execute executes the request
//  @return CancelMoneyInOutput
func (a *MoneyInsCardsApiService) MoneyInsCancelPutExecute(r ApiMoneyInsCardsCancelPutRequest) (*CancelMoneyInOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelMoneyInOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCancelPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/{transactionid}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionid"+"}", url.PathEscape(parameterToString(r.transactionid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(CancelMoneyInInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardCreatePostRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	authorization *string
	pSUIPAddress *string
	parameters *MoneyInCreateInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardCreatePostRequest) Authorization(authorization string) ApiMoneyInsCardCreatePostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardCreatePostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardCreatePostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardCreatePostRequest) Parameters(parameters MoneyInCreateInput) ApiMoneyInsCardCreatePostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardCreatePostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardCreatePostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardCreatePostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardCreatePostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardCreatePostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardCreatePostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardCreatePostRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardCreatePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardCreatePostRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardCreatePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardCreatePostRequest) Execute() (*MoneyInOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardCreatePostExecute(r)
}

/*
MoneyInsCardCreatePost Credit an Account with Money-In with Card without PSP process

Credit an account with Money-In with card without PSP process.
This functionality is available depending on your contract.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsCardCreatePostRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardCreatePost(ctx context.Context) ApiMoneyInsCardCreatePostRequest {
	return ApiMoneyInsCardCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyInOutput
func (a *MoneyInsCardsApiService) MoneyInsCardCreatePostExecute(r ApiMoneyInsCardCreatePostRequest) (*MoneyInOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyInOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyInCreateInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardDirect3DAuthenticatePostRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	transactionid int64
	authorization *string
	pSUIPAddress *string
	parameters *MoneyIn3DAuthenticateInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) Authorization(authorization string) ApiMoneyInsCardDirect3DAuthenticatePostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardDirect3DAuthenticatePostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) Parameters(parameters MoneyIn3DAuthenticateInput) ApiMoneyInsCardDirect3DAuthenticatePostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardDirect3DAuthenticatePostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardDirect3DAuthenticatePostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardDirect3DAuthenticatePostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardDirect3DAuthenticatePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardDirect3DAuthenticatePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardDirect3DAuthenticatePostRequest) Execute() (*MoneyIn3DAuthenticateOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardDirect3DAuthenticatePostExecute(r)
}

/*
MoneyInsCardDirect3DAuthenticatePost Check Money-In 3D-Secure Status (PCI-DSS compliant only)

After initializing a 3-D Secure transaction with <b>POST /moneyins/card/direct/3dinit</b>, you can choose not to debit the card, and only check if the user has successfully authenticated.<br /><b>This is not a payment.</b><br />
You can not use both <b>POST /moneyins/card/direct/{transactionid}/3dauthenticate</b> and <b>PUT /moneyins/card/direct/{transactionid}/3dconfirm</b>
 - If you only want to check if the user was correctly authenticated use <b>POST /moneyins/card/direct/{transactionid}/3dauthenticate</b>)
 - If you want to receive the payment using 3-DS use <b>PUT /moneyins/card/direct/{transactionid}/3dconfirm</b><br />
A typical use-case: you want to allow your user to save a card for rebills (RegisterCard), but first, you want to make sure that the card belongs to the user and that the user can authenticate successfully.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionid
 @return ApiMoneyInsCardDirect3DAuthenticatePostRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardDirect3DAuthenticatePost(ctx context.Context, transactionid int64) ApiMoneyInsCardDirect3DAuthenticatePostRequest {
	return ApiMoneyInsCardDirect3DAuthenticatePostRequest{
		ApiService: a,
		ctx: ctx,
		transactionid: transactionid,
	}
}

// Execute executes the request
//  @return MoneyIn3DAuthenticateOutput
func (a *MoneyInsCardsApiService) MoneyInsCardDirect3DAuthenticatePostExecute(r ApiMoneyInsCardDirect3DAuthenticatePostRequest) (*MoneyIn3DAuthenticateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyIn3DAuthenticateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardDirect3DAuthenticatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/direct/{transactionid}/3dauthenticate"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionid"+"}", url.PathEscape(parameterToString(r.transactionid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyIn3DAuthenticateInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardDirect3DConfirmPutRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	transactionid int64
	authorization *string
	pSUIPAddress *string
	parameters *MoneyIn3DConfirmInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardDirect3DConfirmPutRequest) Authorization(authorization string) ApiMoneyInsCardDirect3DConfirmPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardDirect3DConfirmPutRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardDirect3DConfirmPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardDirect3DConfirmPutRequest) Parameters(parameters MoneyIn3DConfirmInput) ApiMoneyInsCardDirect3DConfirmPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardDirect3DConfirmPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardDirect3DConfirmPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardDirect3DConfirmPutRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardDirect3DConfirmPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardDirect3DConfirmPutRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardDirect3DConfirmPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardDirect3DConfirmPutRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardDirect3DConfirmPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardDirect3DConfirmPutRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardDirect3DConfirmPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardDirect3DConfirmPutRequest) Execute() (*MoneyIn3DConfirmOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardDirect3DConfirmPutExecute(r)
}

/*
MoneyInsCardDirect3DConfirmPut Finalize a Direct Payment (PCI-DSS compliant only)

This method finalizes the credit of a wallet by card after 3D Secure authentication of the client:<br />
1. After initiating a Direct Payment using <b>POST /moneyins/card/direct/3dinit</b>, you receive an Authentication URL and a Transaction Id. If you want to register a card for future payments set **registerCard=true**
2. With the Authentication URL, you are able to redirect the end-user to the ACS (Bank Authentication Server) Page
3. After 3D Secure Authentication, you will be called back on the ReturnURL
4. You need to then call <b>POST /moneyins/card/direct/{transactionid}/3dauthenticate</b> to verify the authentication process was done.
5. If the authentication was done then call <b>PUT /moneyins/card/direct/{transactionid}/3dconfirm</b> specifying the return Transaction ID to finalize the payment. <br />
For Subscriptions with equal recurring amounts: for the initial subscription payment, use the <b>POST /moneyins/card/direct/3dinit</b> and then <b>POST /moneyins/card/direct/{transactionid}/3dauthenticate</b> and <b>PUT /moneyins/card/direct/{transactionid}/3dconfirm</b> Ensure that you set: <b>registerCard=true</b> Use POST /moneyins/card/{cardid}/rebill for all subsequent payments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionid
 @return ApiMoneyInsCardDirect3DConfirmPutRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardDirect3DConfirmPut(ctx context.Context, transactionid int64) ApiMoneyInsCardDirect3DConfirmPutRequest {
	return ApiMoneyInsCardDirect3DConfirmPutRequest{
		ApiService: a,
		ctx: ctx,
		transactionid: transactionid,
	}
}

// Execute executes the request
//  @return MoneyIn3DConfirmOutput
func (a *MoneyInsCardsApiService) MoneyInsCardDirect3DConfirmPutExecute(r ApiMoneyInsCardDirect3DConfirmPutRequest) (*MoneyIn3DConfirmOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyIn3DConfirmOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardDirect3DConfirmPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/direct/{transactionid}/3dconfirm"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionid"+"}", url.PathEscape(parameterToString(r.transactionid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyIn3DConfirmInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardDirectPostRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	authorization *string
	pSUIPAddress *string
	parameters *MoneyInInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardDirectPostRequest) Authorization(authorization string) ApiMoneyInsCardDirectPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardDirectPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardDirectPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardDirectPostRequest) Parameters(parameters MoneyInInput) ApiMoneyInsCardDirectPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardDirectPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardDirectPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardDirectPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardDirectPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardDirectPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardDirectPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardDirectPostRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardDirectPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardDirectPostRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardDirectPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardDirectPostRequest) Execute() (*MoneyInOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardDirectPostExecute(r)
}

/*
MoneyInsCardDirectPost (Deprecated) Credit an Account with a non 3-D Secure Card Payment (PCI-DSS compliant only)

<b>If your system is not PCI-DSS do not to save any card data on your system.</b>
            This method enables you to credit an account with a non 3-D Secure card payment. Should only be used on mobile devices. For internet payments use 3-D Secure.<br />
            This method allows our system to credit a wallet and debit a card in real time. Your server has to send us the wallet ID to credit, all card data, the amount, and a comment.<br /><b>Note:</b> Lemonway does not recommend you use the MoneyIn method from January 2021. You should now use `POST /moneyins/card/direct/3dini` and `PUT /moneyins/card/direct/{transactionid}/3dconfirm` only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsCardDirectPostRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardDirectPost(ctx context.Context) ApiMoneyInsCardDirectPostRequest {
	return ApiMoneyInsCardDirectPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyInOutput
func (a *MoneyInsCardsApiService) MoneyInsCardDirectPostExecute(r ApiMoneyInsCardDirectPostRequest) (*MoneyInOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyInOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardDirectPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/direct"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyInInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardGetRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	cardId int64
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardGetRequest) Authorization(authorization string) ApiMoneyInsCardGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardGetRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardGetRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardGetRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardGetRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardGetRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardGetRequest) Execute() (*GetCardOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardGetExecute(r)
}

/*
MoneyInsCardGet Get Card Information

Lets you retrieve card information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardId
 @return ApiMoneyInsCardGetRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardGet(ctx context.Context, cardId int64) ApiMoneyInsCardGetRequest {
	return ApiMoneyInsCardGetRequest{
		ApiService: a,
		ctx: ctx,
		cardId: cardId,
	}
}

// Execute executes the request
//  @return GetCardOutput
func (a *MoneyInsCardsApiService) MoneyInsCardGetExecute(r ApiMoneyInsCardGetRequest) (*GetCardOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCardOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/{cardId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cardId"+"}", url.PathEscape(parameterToString(r.cardId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardGet_0Request struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardGet_0Request) Authorization(authorization string) ApiMoneyInsCardGet_0Request {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardGet_0Request) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardGet_0Request {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardGet_0Request) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardGet_0Request {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardGet_0Request) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardGet_0Request {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardGet_0Request) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardGet_0Request {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardGet_0Request) AuthorizationBasicFromProvider() ApiMoneyInsCardGet_0Request {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardGet_0Request) AuthorizationBearerFromProvider() ApiMoneyInsCardGet_0Request {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardGet_0Request) Execute() (*AccountCardsOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardGet_1Execute(r)
}

/*
MoneyInsCardGet_0 Get the Card Associated to a Payment Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiMoneyInsCardGet_0Request
*/
func (a *MoneyInsCardsApiService) MoneyInsCardGet_1(ctx context.Context, accountid string) ApiMoneyInsCardGet_0Request {
	return ApiMoneyInsCardGet_0Request{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return AccountCardsOutput
func (a *MoneyInsCardsApiService) MoneyInsCardGet_1Execute(r ApiMoneyInsCardGet_0Request) (*AccountCardsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountCardsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardGet_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/{accountid}/card"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardRebillRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	cardid int64
	authorization *string
	pSUIPAddress *string
	parameters *MoneyInWithCardIdInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardRebillRequest) Authorization(authorization string) ApiMoneyInsCardRebillRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardRebillRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardRebillRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardRebillRequest) Parameters(parameters MoneyInWithCardIdInput) ApiMoneyInsCardRebillRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardRebillRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardRebillRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardRebillRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardRebillRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardRebillRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardRebillRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardRebillRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardRebillRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardRebillRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardRebillRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardRebillRequest) Execute() (*MoneyInWithCardIdOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardRebillExecute(r)
}

/*
MoneyInsCardRebill Charge a Registered Card

<b>Important:</b> Due to PSD2 requirements for strong authentication, rebilling with a registered card <b>for amounts that change on each transaction</b> is no longer available. In the short-term, for completely new transactions, we kindly ask you to use <b>POST /moneyins/card/webinit</b> and ask your clients to re-enter their card details in the payment page. <br /><br />
            Use this method to ask to credit a payment account with a card linked to the payment account: <br /><br />
            1. The payment account ID to credit <br />
            2. The card ID <br />
            3. The amount to credit <br />
            4. A comment explaining the rebill <br />
            It is important that you clarify why the card was rebilled for security and fraud reasons. Consider the following questions:
            Is it a monthly payment for a service?, if so, which service?
            What is name of the purchase website?, what was ordered?, and what email was used? Ensure that you add all information regarding the rebill 
            in the provided comment field. <br /><br /><b>Important:</b> We may request further information to answer complains directly coming 
            to our Customer Service from your customers, or from Banks,Police,Visa/Mastercard, or from the financial regulator. <br /><br /><b>Recurring Payments</b><br /><b>Initiate a first transaction</b><br />
               a. If you are using the PSP Payment Page, you need to have initiated a Web Payment using <b>POST /moneyins/card/webinit</b> with <b>registerCard=true</b>. <b>The amount of the first transaction has to be higher than the recurring payments.</b><br />
               b. If you are using the Direct Mode (PCI-DSS complient only), you need to have registered a Card using <b>POST /moneyins/card/register</b>. <br /><b>Recurring payments</b><br />
             You need to call <b>POST /moneyins/card/{cardid}/rebill</b> each time you want to make a recurring payment, precising the Card Id returned from step 1. <br /><b>Payment Upon Delivery (Web PSP Payment only)</b><br />
               a. The day of the purchase: you need to have initiated a Web Payment using <b>POST /moneyins/card/webinit</b> with <b>registerCard=true</b>. You also need to indicate in captureDelayedDays, a number between 1 and 6 days. The amount of the first transaction has to be the same than the one captured later. <br />
               b. The day of the service or product delivery: you need to call <b>POST /moneyins/card/{cardid}/rebill</b> precising the Card Id returned from step 1. <br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardid
 @return ApiMoneyInsCardRebillRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardRebill(ctx context.Context, cardid int64) ApiMoneyInsCardRebillRequest {
	return ApiMoneyInsCardRebillRequest{
		ApiService: a,
		ctx: ctx,
		cardid: cardid,
	}
}

// Execute executes the request
//  @return MoneyInWithCardIdOutput
func (a *MoneyInsCardsApiService) MoneyInsCardRebillExecute(r ApiMoneyInsCardRebillRequest) (*MoneyInWithCardIdOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyInWithCardIdOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardRebill")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/{cardid}/rebill"
	localVarPath = strings.Replace(localVarPath, "{"+"cardid"+"}", url.PathEscape(parameterToString(r.cardid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyInWithCardIdInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardRegisterPostRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	authorization *string
	pSUIPAddress *string
	parameters *RegisterCardInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardRegisterPostRequest) Authorization(authorization string) ApiMoneyInsCardRegisterPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardRegisterPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardRegisterPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardRegisterPostRequest) Parameters(parameters RegisterCardInput) ApiMoneyInsCardRegisterPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardRegisterPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardRegisterPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardRegisterPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardRegisterPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardRegisterPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardRegisterPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardRegisterPostRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardRegisterPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardRegisterPostRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardRegisterPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardRegisterPostRequest) Execute() (*RegisterCardOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardRegisterPostExecute(r)
}

/*
MoneyInsCardRegisterPost (Deprecated) Register a Card for Direct Payments (PCI-DSS compliant only)

Register a card and associate it with a Payment Account. The end-user does not have to re-enter their card details for future payments.<br /><b>Important:</b> Ensure your website login is secured to avoid any security breach that may causes unauthorized access (for example, phishing). <br /><b>Note:</b> Lemonway does not recommend you use the MoneyIn method from January 2021. You should now use POST /moneyins/card/direct/3dini and PUT /moneyins/card/direct/{transactionid}/3dconfirm only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsCardRegisterPostRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardRegisterPost(ctx context.Context) ApiMoneyInsCardRegisterPostRequest {
	return ApiMoneyInsCardRegisterPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterCardOutput
func (a *MoneyInsCardsApiService) MoneyInsCardRegisterPostExecute(r ApiMoneyInsCardRegisterPostRequest) (*RegisterCardOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterCardOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardRegisterPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(RegisterCardInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardSubscriptionPostRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	cardid int64
	authorization *string
	pSUIPAddress *string
	parameters *MoneyInSubscriptionInitInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardSubscriptionPostRequest) Authorization(authorization string) ApiMoneyInsCardSubscriptionPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardSubscriptionPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardSubscriptionPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardSubscriptionPostRequest) Parameters(parameters MoneyInSubscriptionInitInput) ApiMoneyInsCardSubscriptionPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardSubscriptionPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardSubscriptionPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardSubscriptionPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardSubscriptionPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardSubscriptionPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardSubscriptionPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardSubscriptionPostRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardSubscriptionPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardSubscriptionPostRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardSubscriptionPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardSubscriptionPostRequest) Execute() (*MoneyInSubscriptionInitOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardSubscriptionPostExecute(r)
}

/*
MoneyInsCardSubscriptionPost Initiate Monthly Recurring Payments

Use the following steps to ensure a recurring payment can be setup:  
1. Initiate a first transaction  
   If you are using the **PSP Payment** Page, you need to have initiated a Web Payment using `POST /moneyins/card/webinit` with **registerCard=true**.     
   If you are using the **Direct Mode** (PCI-DSS authorization required), you need to have registered a card using `POST /moneyins/card/register`.  
    
2. You then need to initiate `POST /moneyins/card/{cardid}/subscription` specifying the Card Id returned from the first transaction, and the Subscription Id (a unique reference you indicate for this subscription).You will also need to precise the number of Recurring Payments you want us to initiate in count. The TotalAmount corresponds to the amount of each recurring payment. By default, the payment will be processed 15th of the month.  
3. We will create scheduled transactions in the Lemonway Dashboard (status 14)   
4. On each payment execution date, Lemonway will debit the card and change the pending transaction status to success, and then notify you.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardid
 @return ApiMoneyInsCardSubscriptionPostRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardSubscriptionPost(ctx context.Context, cardid int64) ApiMoneyInsCardSubscriptionPostRequest {
	return ApiMoneyInsCardSubscriptionPostRequest{
		ApiService: a,
		ctx: ctx,
		cardid: cardid,
	}
}

// Execute executes the request
//  @return MoneyInSubscriptionInitOutput
func (a *MoneyInsCardsApiService) MoneyInsCardSubscriptionPostExecute(r ApiMoneyInsCardSubscriptionPostRequest) (*MoneyInSubscriptionInitOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyInSubscriptionInitOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardSubscriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/{cardid}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"cardid"+"}", url.PathEscape(parameterToString(r.cardid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyInSubscriptionInitInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardUnregisterPutRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	cardid int64
	authorization *string
	pSUIPAddress *string
	parameters *UnregisterCardInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardUnregisterPutRequest) Authorization(authorization string) ApiMoneyInsCardUnregisterPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardUnregisterPutRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardUnregisterPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardUnregisterPutRequest) Parameters(parameters UnregisterCardInput) ApiMoneyInsCardUnregisterPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardUnregisterPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardUnregisterPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardUnregisterPutRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardUnregisterPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardUnregisterPutRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardUnregisterPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardUnregisterPutRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardUnregisterPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardUnregisterPutRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardUnregisterPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardUnregisterPutRequest) Execute() (*UnregisterCardOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardUnregisterPutExecute(r)
}

/*
MoneyInsCardUnregisterPut Unregister a Card Token

This method lets you unregister (break the link) between a card and a payment account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardid
 @return ApiMoneyInsCardUnregisterPutRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardUnregisterPut(ctx context.Context, cardid int64) ApiMoneyInsCardUnregisterPutRequest {
	return ApiMoneyInsCardUnregisterPutRequest{
		ApiService: a,
		ctx: ctx,
		cardid: cardid,
	}
}

// Execute executes the request
//  @return UnregisterCardOutput
func (a *MoneyInsCardsApiService) MoneyInsCardUnregisterPutExecute(r ApiMoneyInsCardUnregisterPutRequest) (*UnregisterCardOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnregisterCardOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardUnregisterPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/{cardid}/unregister"
	localVarPath = strings.Replace(localVarPath, "{"+"cardid"+"}", url.PathEscape(parameterToString(r.cardid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(UnregisterCardInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsCardWebInitPostRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	authorization *string
	pSUIPAddress *string
	parameters *MoneyInWebInitInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardWebInitPostRequest) Authorization(authorization string) ApiMoneyInsCardWebInitPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardWebInitPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardWebInitPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardWebInitPostRequest) Parameters(parameters MoneyInWebInitInput) ApiMoneyInsCardWebInitPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardWebInitPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardWebInitPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardWebInitPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardWebInitPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardWebInitPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardWebInitPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardWebInitPostRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardWebInitPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardWebInitPostRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardWebInitPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardWebInitPostRequest) Execute() (*MoneyInWebInitOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardWebInitPostExecute(r)
}

/*
MoneyInsCardWebInitPost Initiate a Web Payment

**Payment with a New Card**  
1. By calling `POST /moneyins/card/webinit`, you receive a MoneyInToken. If you want to register a card for future payments set `registerCard=true` and you will also receive a `cardId`    
2. With this token, you are able to redirect the end-user on the PSP payment page. You have to combine the Token and the Lemonway Webkit URL to get the Payment Page URL. You can find the Webkit URL in the onboarding email. For example: `https://sandbox-webkit.lemonway.fr/YOUR_COMPANY/dev/ `  
3. After submitting the payment, the end-user will be redirected to:  
   - `returnUrl` in case of success  
   - `cancelUrl` in case of cancellation   
   - `errorUrl` in case of error    

These 3 URLs must be public accessible so your end-user, and our WebKit server could send requests to them.  

---
**Payment with a Registered Card (Web)**  
To use this type of payment you have to make at least one transaction and set `registerCard=true`. On this first transaction, we will return a `cardId` that is associated with the client card. Ensure that you save this `cardId` to use for future payment.  
**Note:** To ensure that the Client’s card has been registered, call the following method before you initiative payments on a registered card: `GetCard`   
Payments on a registered card use the following process:  
1. You call `MoneyInWebInit` ensuring that you include the `cardId` in the body of the request. Refer to **steps 2 and 3** as stated above.
---
**Subscription Payments**   
A prerequisite to setting up a subscription is that you have previously made a payment with a card and registered the card By calling `POST /moneyins/card/webinit`   
**Note:** When you create a recurring payment ensure that the `recurringAvgAmount` is higher than `totalAmount`. If a lower amount is used for `recurringAvgAmount` you will receive a  directkit error message: 368: `recurringAvgAmount` stating that the amount should be greater than the transaction amount.  
**Note:** Initial transaction for a subscription can be for a predetermined or an undetermined length of time.  
After you have registered a card refer to `POST /moneyins/card/{cardid}/rebill` to begin setting up a subscription or payment by delivery system.  
**Important:** To ensure the likelyhood of frictionless payments you must setup payments of equal recurring amounts.
---
**Deferred Payments**   
If you want to create a deferred Web payment, in the request please indicate within `captureDelayedDays`, a number between 1 and 6 days to have a guaranteed payment.  
To validate the pre-authorization and capture funds, you need to call `PUT /moneyins/{transactionid}/validate` before 6 days. If the capture is a success, then the original transaction status switches to Success.  
Available on Mercanet v2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsCardWebInitPostRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsCardWebInitPost(ctx context.Context) ApiMoneyInsCardWebInitPostRequest {
	return ApiMoneyInsCardWebInitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyInWebInitOutput
func (a *MoneyInsCardsApiService) MoneyInsCardWebInitPostExecute(r ApiMoneyInsCardWebInitPostRequest) (*MoneyInWebInitOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyInWebInitOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsCardWebInitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/webinit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyInWebInitInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsDirect3DInitPostRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	authorization *string
	pSUIPAddress *string
	parameters *MoneyIn3DInitInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsDirect3DInitPostRequest) Authorization(authorization string) ApiMoneyInsDirect3DInitPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsDirect3DInitPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsDirect3DInitPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsDirect3DInitPostRequest) Parameters(parameters MoneyIn3DInitInput) ApiMoneyInsDirect3DInitPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsDirect3DInitPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsDirect3DInitPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsDirect3DInitPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsDirect3DInitPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsDirect3DInitPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsDirect3DInitPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsDirect3DInitPostRequest) AuthorizationBasicFromProvider() ApiMoneyInsDirect3DInitPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsDirect3DInitPostRequest) AuthorizationBearerFromProvider() ApiMoneyInsDirect3DInitPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsDirect3DInitPostRequest) Execute() (*MoneyIn3DInitOutput, *http.Response, error) {
	return r.ApiService.MoneyInsDirect3DInitPostExecute(r)
}

/*
MoneyInsDirect3DInitPost Initiate a Direct Payment (PCI-DSS compliant only)

**Payment with a New Card**  
This method is more complex that non 3-D Secure payment, but 3-D Secure will ensure that your business is secure.  
You will need 3 integration points:  
1. By calling `POST /moneyins/card/direct/3dinit`, you receive a Authentication URL and a Transaction Id.  If you want to register a card for to use card severval times or subscription payments set **registerCard=true.**  
2. With the Authentication URL, you are able to redirect the end-user to the ACS (Bank Authentication Server) Page.    
3. After 3D Secure Authentication, with the callback ReturnURL.  
4. You need to then call `POST /moneyins/card/direct/{transactionid}/3dauthenticate` to verify the authentication process was done.  
5. If the authentication was done then, you then call `PUT /moneyins/card/direct/{transactionid}/3dconfirm` specifying the returned Transaction Id to finalize the payment.
---
**Payment with a Registered Card**  
1. Ensure you have a cardId then call `POST /moneyins/card/direct/3dinit` specifying the cardID parameter (cardId and CVV (optional)). If you want to improve the transaction success rate add the CVV code in the parameters.  
2. Refer to **steps 2 - 5** as stated above.  
**Note:** You require a cardId to make a transaction on a registered card.  This id is displayed when you finalized your first payment with the registered card using `PUT /moneyins/card/direct/{transactionid}/3dconfirm`   
Payments on a registered card use the following process:  
Call MoneyIn3DInit ensuring that you include the `cardId` in the body of the request. Refer to steps **2 - 5**  as stated above.  
**Note:** To ensure that the client’s card has been registered, call the following method before you initiative payments on a registered card: `GetCard`
---
**Subscription Payments**   
A prerequisite to setting up a subscription is that you have previously made a payment with a card and registered the card using `POST /moneyins/card/direct/3dinit` 
**Note:** When you create a recurring payment ensure that the `recurringAvgAmount` is higher than totalAmount. If a lower amount is used for `recurringAvgAmount` you will receive a directkit error message 368: `recurringAvgAmount` should be greater than the transaction amount.  
**Note:** After you have registered a card refer to `POST /moneyins/card/{cardid}/rebill` to begin setting up a subscription or payment by delivery system.  
**Important:** To ensure the likelyhood of frictionless payments you must setup payments of equal recurring amounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsDirect3DInitPostRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsDirect3DInitPost(ctx context.Context) ApiMoneyInsDirect3DInitPostRequest {
	return ApiMoneyInsDirect3DInitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyIn3DInitOutput
func (a *MoneyInsCardsApiService) MoneyInsDirect3DInitPostExecute(r ApiMoneyInsDirect3DInitPostRequest) (*MoneyIn3DInitOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyIn3DInitOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsDirect3DInitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/direct/3dinit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyIn3DInitInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsMoneyInGetRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	authorization *string
	pSUIPAddress *string
	transactionId *int64
	transactionComment *string
	transactionMerchantToken *string
	startDate *string
	endDate *string
	page *int32
	limit *int32
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsMoneyInGetRequest) Authorization(authorization string) ApiMoneyInsMoneyInGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsMoneyInGetRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsMoneyInGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Money-In ID
func (r ApiMoneyInsMoneyInGetRequest) TransactionId(transactionId int64) ApiMoneyInsMoneyInGetRequest {
	r.transactionId = &transactionId
	return r
}

// Money-In Comment
func (r ApiMoneyInsMoneyInGetRequest) TransactionComment(transactionComment string) ApiMoneyInsMoneyInGetRequest {
	r.transactionComment = &transactionComment
	return r
}

// Unique ID generated by your server. This ID can be used as a reference for a search field when looking for operation details.
func (r ApiMoneyInsMoneyInGetRequest) TransactionMerchantToken(transactionMerchantToken string) ApiMoneyInsMoneyInGetRequest {
	r.transactionMerchantToken = &transactionMerchantToken
	return r
}

// UTC Unix timestamp, in order to return transactions initialized after it
func (r ApiMoneyInsMoneyInGetRequest) StartDate(startDate string) ApiMoneyInsMoneyInGetRequest {
	r.startDate = &startDate
	return r
}

// UTC Unix timestamp, in order to return transactions initialized before it
func (r ApiMoneyInsMoneyInGetRequest) EndDate(endDate string) ApiMoneyInsMoneyInGetRequest {
	r.endDate = &endDate
	return r
}

// Index start from 1, let null to get all
func (r ApiMoneyInsMoneyInGetRequest) Page(page int32) ApiMoneyInsMoneyInGetRequest {
	r.page = &page
	return r
}

// Default 20, let it null if no pagination
func (r ApiMoneyInsMoneyInGetRequest) Limit(limit int32) ApiMoneyInsMoneyInGetRequest {
	r.limit = &limit
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsMoneyInGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsMoneyInGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsMoneyInGetRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsMoneyInGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsMoneyInGetRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsMoneyInGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsMoneyInGetRequest) AuthorizationBasicFromProvider() ApiMoneyInsMoneyInGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsMoneyInGetRequest) AuthorizationBearerFromProvider() ApiMoneyInsMoneyInGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsMoneyInGetRequest) Execute() (*GetMoneyInTransDetailsOutput, *http.Response, error) {
	return r.ApiService.MoneyInsMoneyInGetExecute(r)
}

/*
MoneyInsMoneyInGet Retrieve Payment Details

Retrieves the details of a Payment that has previously been initiated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsMoneyInGetRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsMoneyInGet(ctx context.Context) ApiMoneyInsMoneyInGetRequest {
	return ApiMoneyInsMoneyInGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMoneyInTransDetailsOutput
func (a *MoneyInsCardsApiService) MoneyInsMoneyInGetExecute(r ApiMoneyInsMoneyInGetRequest) (*GetMoneyInTransDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMoneyInTransDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsMoneyInGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.transactionComment != nil {
		localVarQueryParams.Add("transactionComment", parameterToString(*r.transactionComment, ""))
	}
	if r.transactionMerchantToken != nil {
		localVarQueryParams.Add("transactionMerchantToken", parameterToString(*r.transactionMerchantToken, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsValidatePutRequest struct {
	ctx context.Context
	ApiService *MoneyInsCardsApiService
	transactionid int64
	authorization *string
	pSUIPAddress *string
	parameters *MoneyInValidateInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsValidatePutRequest) Authorization(authorization string) ApiMoneyInsValidatePutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsValidatePutRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsValidatePutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsValidatePutRequest) Parameters(parameters MoneyInValidateInput) ApiMoneyInsValidatePutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsValidatePutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsValidatePutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsValidatePutRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsValidatePutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsValidatePutRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsValidatePutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsValidatePutRequest) AuthorizationBasicFromProvider() ApiMoneyInsValidatePutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsValidatePutRequest) AuthorizationBearerFromProvider() ApiMoneyInsValidatePutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsValidatePutRequest) Execute() (*MoneyInValidateOutput, *http.Response, error) {
	return r.ApiService.MoneyInsValidatePutExecute(r)
}

/*
MoneyInsValidatePut Capture a Deferred Payment

This call is only used in deferred payment. Pre-authroriztion validation can only be done once.
1. After initiating a pre-authorized Web Payment using `POST /moneyins/card/webinit`, you received a Transaction Id from Lemonway.
2. Depending on the number you specified as captureDelayedDays, funds are blocked between 1 to 6 days maximum.
3. To validate the pre-authorization, you need to call `PUT /moneyins/{transactionid}/validate`. If the capture is a success, then the original transaction status switches to Success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionid
 @return ApiMoneyInsValidatePutRequest
*/
func (a *MoneyInsCardsApiService) MoneyInsValidatePut(ctx context.Context, transactionid int64) ApiMoneyInsValidatePutRequest {
	return ApiMoneyInsValidatePutRequest{
		ApiService: a,
		ctx: ctx,
		transactionid: transactionid,
	}
}

// Execute executes the request
//  @return MoneyInValidateOutput
func (a *MoneyInsCardsApiService) MoneyInsValidatePutExecute(r ApiMoneyInsValidatePutRequest) (*MoneyInValidateOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyInValidateOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsCardsApiService.MoneyInsValidatePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/{transactionid}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionid"+"}", url.PathEscape(parameterToString(r.transactionid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(MoneyInValidateInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
