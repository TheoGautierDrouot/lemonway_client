/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AccountsAdminApiService AccountsAdminApi service
type AccountsAdminApiService service

type ApiAccountsAccountSingleGetRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsAccountSingleGetRequest) Authorization(authorization string) ApiAccountsAccountSingleGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsAccountSingleGetRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsAccountSingleGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsAccountSingleGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsAccountSingleGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsAccountSingleGetRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsAccountSingleGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsAccountSingleGetRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsAccountSingleGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsAccountSingleGetRequest) AuthorizationBasicFromProvider() ApiAccountsAccountSingleGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsAccountSingleGetRequest) AuthorizationBearerFromProvider() ApiAccountsAccountSingleGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsAccountSingleGetRequest) Execute() (*AccountDetailsOutput, *http.Response, error) {
	return r.ApiService.AccountsAccountSingleGetExecute(r)
}

/*
AccountsAccountSingleGet Get Detailed Payment Account Data

Enables your system to get detailed payment account information including:   
* Payment account balance   
* Account type    
* Account status (if blocked or not) 
* Account email address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiAccountsAccountSingleGetRequest
*/
func (a *AccountsAdminApiService) AccountsAccountSingleGet(ctx context.Context, accountid string) ApiAccountsAccountSingleGetRequest {
	return ApiAccountsAccountSingleGetRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return AccountDetailsOutput
func (a *AccountsAdminApiService) AccountsAccountSingleGetExecute(r ApiAccountsAccountSingleGetRequest) (*AccountDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsAccountSingleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountid}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsBalancesGetRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	authorization *string
	pSUIPAddress *string
	updateDate *string
	internalAccountIdStart *int64
	internalAccountIdEnd *int64
	page *int32
	limit *int32
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsBalancesGetRequest) Authorization(authorization string) ApiAccountsBalancesGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsBalancesGetRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsBalancesGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Date in UTC Seconds  Leave empty to use payment account IDs.
func (r ApiAccountsBalancesGetRequest) UpdateDate(updateDate string) ApiAccountsBalancesGetRequest {
	r.updateDate = &updateDate
	return r
}

// First payment account internal ID, starting from 12.
func (r ApiAccountsBalancesGetRequest) InternalAccountIdStart(internalAccountIdStart int64) ApiAccountsBalancesGetRequest {
	r.internalAccountIdStart = &internalAccountIdStart
	return r
}

// Last payment account internal ID, starting from 12.
func (r ApiAccountsBalancesGetRequest) InternalAccountIdEnd(internalAccountIdEnd int64) ApiAccountsBalancesGetRequest {
	r.internalAccountIdEnd = &internalAccountIdEnd
	return r
}

// Index start from 1, let null to get all
func (r ApiAccountsBalancesGetRequest) Page(page int32) ApiAccountsBalancesGetRequest {
	r.page = &page
	return r
}

// Default 20, let it null if no pagination
func (r ApiAccountsBalancesGetRequest) Limit(limit int32) ApiAccountsBalancesGetRequest {
	r.limit = &limit
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsBalancesGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsBalancesGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsBalancesGetRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsBalancesGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsBalancesGetRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsBalancesGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsBalancesGetRequest) AuthorizationBasicFromProvider() ApiAccountsBalancesGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsBalancesGetRequest) AuthorizationBearerFromProvider() ApiAccountsBalancesGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsBalancesGetRequest) Execute() (*AccountBalanceOutput, *http.Response, error) {
	return r.ApiService.AccountsBalancesGetExecute(r)
}

/*
AccountsBalancesGet Get all Payment Account Balances

Use `GetBalances` to get all payment accounts where the balance has changed since the input date, or all the balances of payment accounts with internal ID between payment `accountIdStart` and payment `accountIdEnd`.

**Important:** Payment account balances can not be viewed for special accounts SC **11** and LW **4** using the `accountId` parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountsBalancesGetRequest
*/
func (a *AccountsAdminApiService) AccountsBalancesGet(ctx context.Context) ApiAccountsBalancesGetRequest {
	return ApiAccountsBalancesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountBalanceOutput
func (a *AccountsAdminApiService) AccountsBalancesGetExecute(r ApiAccountsBalancesGetRequest) (*AccountBalanceOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountBalanceOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsBalancesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	if r.updateDate != nil {
		localVarQueryParams.Add("updateDate", parameterToString(*r.updateDate, ""))
	}
	if r.internalAccountIdStart != nil {
		localVarQueryParams.Add("internalAccountIdStart", parameterToString(*r.internalAccountIdStart, ""))
	}
	if r.internalAccountIdEnd != nil {
		localVarQueryParams.Add("internalAccountIdEnd", parameterToString(*r.internalAccountIdEnd, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsBalancesHistoryGetRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	accountId string
	authorization *string
	pSUIPAddress *string
	atDate *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsBalancesHistoryGetRequest) Authorization(authorization string) ApiAccountsBalancesHistoryGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsBalancesHistoryGetRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsBalancesHistoryGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Request balance at given time in UTC Unix timestamp.
func (r ApiAccountsBalancesHistoryGetRequest) AtDate(atDate string) ApiAccountsBalancesHistoryGetRequest {
	r.atDate = &atDate
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsBalancesHistoryGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsBalancesHistoryGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsBalancesHistoryGetRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsBalancesHistoryGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsBalancesHistoryGetRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsBalancesHistoryGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsBalancesHistoryGetRequest) AuthorizationBasicFromProvider() ApiAccountsBalancesHistoryGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsBalancesHistoryGetRequest) AuthorizationBearerFromProvider() ApiAccountsBalancesHistoryGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsBalancesHistoryGetRequest) Execute() (*BalanceHistoryOutput, *http.Response, error) {
	return r.ApiService.AccountsBalancesHistoryGetExecute(r)
}

/*
AccountsBalancesHistoryGet Get Payment Account Balance History

Enter an `accountId` and specify the `atDate` parameter to return an account balance.  

**Important:** Payment account balances can not be viewed for special accounts SC **11** and LW **4** using the `accountId` parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account ID
 @return ApiAccountsBalancesHistoryGetRequest
*/
func (a *AccountsAdminApiService) AccountsBalancesHistoryGet(ctx context.Context, accountId string) ApiAccountsBalancesHistoryGetRequest {
	return ApiAccountsBalancesHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return BalanceHistoryOutput
func (a *AccountsAdminApiService) AccountsBalancesHistoryGetExecute(r ApiAccountsBalancesHistoryGetRequest) (*BalanceHistoryOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalanceHistoryOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsBalancesHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountId}/balances/history"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	if r.atDate != nil {
		localVarQueryParams.Add("atDate", parameterToString(*r.atDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsBlockedPutRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	parameters *AccountBlockedInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsBlockedPutRequest) Authorization(authorization string) ApiAccountsBlockedPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsBlockedPutRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsBlockedPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsBlockedPutRequest) Parameters(parameters AccountBlockedInput) ApiAccountsBlockedPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsBlockedPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsBlockedPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsBlockedPutRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsBlockedPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsBlockedPutRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsBlockedPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsBlockedPutRequest) AuthorizationBasicFromProvider() ApiAccountsBlockedPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsBlockedPutRequest) AuthorizationBearerFromProvider() ApiAccountsBlockedPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsBlockedPutRequest) Execute() (*AccountBlockedOutput, *http.Response, error) {
	return r.ApiService.AccountsBlockedPutExecute(r)
}

/*
AccountsBlockedPut Block or Unblock an Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiAccountsBlockedPutRequest
*/
func (a *AccountsAdminApiService) AccountsBlockedPut(ctx context.Context, accountid string) ApiAccountsBlockedPutRequest {
	return ApiAccountsBlockedPutRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return AccountBlockedOutput
func (a *AccountsAdminApiService) AccountsBlockedPutExecute(r ApiAccountsBlockedPutRequest) (*AccountBlockedOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountBlockedOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsBlockedPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountid}/blocked"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(AccountBlockedInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsDocumentGetRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsDocumentGetRequest) Authorization(authorization string) ApiAccountsDocumentGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsDocumentGetRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsDocumentGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsDocumentGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsDocumentGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsDocumentGetRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsDocumentGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsDocumentGetRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsDocumentGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsDocumentGetRequest) AuthorizationBasicFromProvider() ApiAccountsDocumentGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsDocumentGetRequest) AuthorizationBearerFromProvider() ApiAccountsDocumentGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsDocumentGetRequest) Execute() (*AccountDocumentsOutput, *http.Response, error) {
	return r.ApiService.AccountsDocumentGetExecute(r)
}

/*
AccountsDocumentGet Get Documents Associated with a Payment Account

Returns the document ID, document status, and document type of a users account.
            
**Note:** If you validate your Client's documentation using Lemonway's automated KYC, you will not receive a `validityDate` response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiAccountsDocumentGetRequest
*/
func (a *AccountsAdminApiService) AccountsDocumentGet(ctx context.Context, accountid string) ApiAccountsDocumentGetRequest {
	return ApiAccountsDocumentGetRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return AccountDocumentsOutput
func (a *AccountsAdminApiService) AccountsDocumentGetExecute(r ApiAccountsDocumentGetRequest) (*AccountDocumentsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountDocumentsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsDocumentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountid}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsDocumentsSignInitPostRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	accountid string
	documentid int64
	authorization *string
	pSUIPAddress *string
	parameters *SignDocumentInitInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsDocumentsSignInitPostRequest) Authorization(authorization string) ApiAccountsDocumentsSignInitPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsDocumentsSignInitPostRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsDocumentsSignInitPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsDocumentsSignInitPostRequest) Parameters(parameters SignDocumentInitInput) ApiAccountsDocumentsSignInitPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsDocumentsSignInitPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsDocumentsSignInitPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsDocumentsSignInitPostRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsDocumentsSignInitPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsDocumentsSignInitPostRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsDocumentsSignInitPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsDocumentsSignInitPostRequest) AuthorizationBasicFromProvider() ApiAccountsDocumentsSignInitPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsDocumentsSignInitPostRequest) AuthorizationBearerFromProvider() ApiAccountsDocumentsSignInitPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsDocumentsSignInitPostRequest) Execute() (*SignDocumentInitOutput, *http.Response, error) {
	return r.ApiService.AccountsDocumentsSignInitPostExecute(r)
}

/*
AccountsDocumentsSignInitPost Generate an Electronic Signature of a Document

This call lets you to generate an electronic signature.  

**Note:** Only SDD mandates can be signed with this method.      

**Prerequisite:**  A Mandate needs to be registered with **RegisterSddMandate**

1. A call to `SignDocumentInit` of DirectKit to make the signature request and get a token.  
2. A redirection from your website to the WebKit, with the token in GET parameter (see Finalize document signature).  
3. A return page where your user will be redirected after the signature.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account Id
 @param documentid
 @return ApiAccountsDocumentsSignInitPostRequest
*/
func (a *AccountsAdminApiService) AccountsDocumentsSignInitPost(ctx context.Context, accountid string, documentid int64) ApiAccountsDocumentsSignInitPostRequest {
	return ApiAccountsDocumentsSignInitPostRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
		documentid: documentid,
	}
}

// Execute executes the request
//  @return SignDocumentInitOutput
func (a *AccountsAdminApiService) AccountsDocumentsSignInitPostExecute(r ApiAccountsDocumentsSignInitPostRequest) (*SignDocumentInitOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignDocumentInitOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsDocumentsSignInitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountid}/documents/{documentid}/signinit"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentid"+"}", url.PathEscape(parameterToString(r.documentid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(SignDocumentInitInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsEnrolmentInitRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	parameters *EnrolmentInitInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsEnrolmentInitRequest) Authorization(authorization string) ApiAccountsEnrolmentInitRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsEnrolmentInitRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsEnrolmentInitRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsEnrolmentInitRequest) Parameters(parameters EnrolmentInitInput) ApiAccountsEnrolmentInitRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsEnrolmentInitRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsEnrolmentInitRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsEnrolmentInitRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsEnrolmentInitRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsEnrolmentInitRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsEnrolmentInitRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsEnrolmentInitRequest) AuthorizationBasicFromProvider() ApiAccountsEnrolmentInitRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsEnrolmentInitRequest) AuthorizationBearerFromProvider() ApiAccountsEnrolmentInitRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsEnrolmentInitRequest) Execute() (*EnrolmentInitOutput, *http.Response, error) {
	return r.ApiService.AccountsEnrolmentInitExecute(r)
}

/*
AccountsEnrolmentInit (Deprecated) Initialize a Deutsche Post POSTIDENT Identification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid
 @return ApiAccountsEnrolmentInitRequest
*/
func (a *AccountsAdminApiService) AccountsEnrolmentInit(ctx context.Context, accountid string) ApiAccountsEnrolmentInitRequest {
	return ApiAccountsEnrolmentInitRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return EnrolmentInitOutput
func (a *AccountsAdminApiService) AccountsEnrolmentInitExecute(r ApiAccountsEnrolmentInitRequest) (*EnrolmentInitOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnrolmentInitOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsEnrolmentInit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountid}/enrolment/init"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(EnrolmentInitInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsRetrievePostRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	authorization *string
	pSUIPAddress *string
	parameters *AccountDetailsBatchInput
	page *int32
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsRetrievePostRequest) Authorization(authorization string) ApiAccountsRetrievePostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsRetrievePostRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsRetrievePostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsRetrievePostRequest) Parameters(parameters AccountDetailsBatchInput) ApiAccountsRetrievePostRequest {
	r.parameters = &parameters
	return r
}

func (r ApiAccountsRetrievePostRequest) Page(page int32) ApiAccountsRetrievePostRequest {
	r.page = &page
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsRetrievePostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsRetrievePostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsRetrievePostRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsRetrievePostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsRetrievePostRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsRetrievePostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsRetrievePostRequest) AuthorizationBasicFromProvider() ApiAccountsRetrievePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsRetrievePostRequest) AuthorizationBearerFromProvider() ApiAccountsRetrievePostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsRetrievePostRequest) Execute() (*AccountDetailsBatchOutput, *http.Response, error) {
	return r.ApiService.AccountsRetrievePostExecute(r)
}

/*
AccountsRetrievePost Get Detailed Payments Accounts Data

Lets your system to get detailed payment account information including: 
payment account balance, account type, if the account is blocked, and account email address.  
Fill at least one search field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountsRetrievePostRequest
*/
func (a *AccountsAdminApiService) AccountsRetrievePost(ctx context.Context) ApiAccountsRetrievePostRequest {
	return ApiAccountsRetrievePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountDetailsBatchOutput
func (a *AccountsAdminApiService) AccountsRetrievePostExecute(r ApiAccountsRetrievePostRequest) (*AccountDetailsBatchOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountDetailsBatchOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsRetrievePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/retrieve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(AccountDetailsBatchInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsTransactionsGetRequest struct {
	ctx context.Context
	ApiService *AccountsAdminApiService
	accountId string
	authorization *string
	pSUIPAddress *string
	startDate *string
	endDate *string
	executionDateStart *string
	executionDateEnd *string
	page *int32
	limit *int32
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsTransactionsGetRequest) Authorization(authorization string) ApiAccountsTransactionsGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsTransactionsGetRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsTransactionsGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// UTC Unix timestamp  In order to return transactions initialized after &#x60;startDate&#x60;.  If the payment account is a **SC Wallet** then this value is mandatory.
func (r ApiAccountsTransactionsGetRequest) StartDate(startDate string) ApiAccountsTransactionsGetRequest {
	r.startDate = &startDate
	return r
}

// UTC Unix timestamp  In order to return transactions initialized before &#x60;endDate&#x60;.  If the payment account is a **SC Wallet** then this value is mandatory and the time span can not exceed 1 week.
func (r ApiAccountsTransactionsGetRequest) EndDate(endDate string) ApiAccountsTransactionsGetRequest {
	r.endDate = &endDate
	return r
}

// UTC Unix timestamp  In order to return transactions Executed after &#x60;endDate&#x60;.  If the payment account is a **SC Wallet** then this value is mandatory and the time span can not exceed 1 week.
func (r ApiAccountsTransactionsGetRequest) ExecutionDateStart(executionDateStart string) ApiAccountsTransactionsGetRequest {
	r.executionDateStart = &executionDateStart
	return r
}

// UTC Unix timestamp  In order to return transactions Executed before &#x60;endDate&#x60;  If the payment account is a **SC Wallet** then this value is mandatory and the time span can not exceed 1 week.
func (r ApiAccountsTransactionsGetRequest) ExecutionDateEnd(executionDateEnd string) ApiAccountsTransactionsGetRequest {
	r.executionDateEnd = &executionDateEnd
	return r
}

// Index start from 1, let null to get all
func (r ApiAccountsTransactionsGetRequest) Page(page int32) ApiAccountsTransactionsGetRequest {
	r.page = &page
	return r
}

// Default 20, let it null if no pagination
func (r ApiAccountsTransactionsGetRequest) Limit(limit int32) ApiAccountsTransactionsGetRequest {
	r.limit = &limit
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsTransactionsGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsTransactionsGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsTransactionsGetRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsTransactionsGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsTransactionsGetRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsTransactionsGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsTransactionsGetRequest) AuthorizationBasicFromProvider() ApiAccountsTransactionsGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsTransactionsGetRequest) AuthorizationBearerFromProvider() ApiAccountsTransactionsGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsTransactionsGetRequest) Execute() (*AccountKycStatusOutput, *http.Response, error) {
	return r.ApiService.AccountsTransactionsGetExecute(r)
}

/*
AccountsTransactionsGet Get list of all Payment Account transactions

Use the `GetWalletTransHistory` to retrieve the list of **Money-In**, **Money-Out** and **P2P (payment between payment account)** of a given payment account.
The following numbered list corresponds to the payment type specified in the response attribute method:  

0 Card  
1 Bank transfer (MoneyIn)   
3 Bank transfer (MoneyOut)   
4 P2P  
13 iDEAL  
14 SEPA DirectDebit  
15 Cheque  
19 Multibanco  
35 PayPal


 ---
 **Important:** The following services have been discontinued. 
 
16 Neosurf  
17 Sofort  
18 PFS Physical Card  
20 Payshop  
21 MBWAY  
22 Polish Instant Transfer  
23 Pagare   
24 MobilePay  
25 Paytrail  
26 WeChat  
27 P24  
28 MoneyIn by TPE  
29 Trustly

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account ID
 @return ApiAccountsTransactionsGetRequest
*/
func (a *AccountsAdminApiService) AccountsTransactionsGet(ctx context.Context, accountId string) ApiAccountsTransactionsGetRequest {
	return ApiAccountsTransactionsGetRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountKycStatusOutput
func (a *AccountsAdminApiService) AccountsTransactionsGetExecute(r ApiAccountsTransactionsGetRequest) (*AccountKycStatusOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountKycStatusOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAdminApiService.AccountsTransactionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.executionDateStart != nil {
		localVarQueryParams.Add("executionDateStart", parameterToString(*r.executionDateStart, ""))
	}
	if r.executionDateEnd != nil {
		localVarQueryParams.Add("executionDateEnd", parameterToString(*r.executionDateEnd, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
