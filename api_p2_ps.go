/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
)


// P2PsApiService P2PsApi service
type P2PsApiService service

type ApiP2PsP2pGetRequest struct {
	ctx context.Context
	ApiService *P2PsApiService
	authorization *string
	pSUIPAddress *string
	transactionId *int64
	transactionComment *string
	reference *string
	privateDataValue *[]string
	page *int32
	limit *int32
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiP2PsP2pGetRequest) Authorization(authorization string) ApiP2PsP2pGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiP2PsP2pGetRequest) PSUIPAddress(pSUIPAddress string) ApiP2PsP2pGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Transaction ID
func (r ApiP2PsP2pGetRequest) TransactionId(transactionId int64) ApiP2PsP2pGetRequest {
	r.transactionId = &transactionId
	return r
}

// Transaction Comment
func (r ApiP2PsP2pGetRequest) TransactionComment(transactionComment string) ApiP2PsP2pGetRequest {
	r.transactionComment = &transactionComment
	return r
}

// Unique ID generated by your server
func (r ApiP2PsP2pGetRequest) Reference(reference string) ApiP2PsP2pGetRequest {
	r.reference = &reference
	return r
}

// Up to 20 fields of 256 maximum length
func (r ApiP2PsP2pGetRequest) PrivateDataValue(privateDataValue []string) ApiP2PsP2pGetRequest {
	r.privateDataValue = &privateDataValue
	return r
}

// Index start from 1, let null to get all
func (r ApiP2PsP2pGetRequest) Page(page int32) ApiP2PsP2pGetRequest {
	r.page = &page
	return r
}

// Default 20, let it null if no pagination
func (r ApiP2PsP2pGetRequest) Limit(limit int32) ApiP2PsP2pGetRequest {
	r.limit = &limit
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiP2PsP2pGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiP2PsP2pGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiP2PsP2pGetRequest) PSUUserAgent(pSUUserAgent string) ApiP2PsP2pGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiP2PsP2pGetRequest) AuthorizationFromProvider(authType AuthType) ApiP2PsP2pGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiP2PsP2pGetRequest) AuthorizationBasicFromProvider() ApiP2PsP2pGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiP2PsP2pGetRequest) AuthorizationBearerFromProvider() ApiP2PsP2pGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiP2PsP2pGetRequest) Execute() (*GetPaymentDetailsOutput, *http.Response, error) {
	return r.ApiService.P2PsP2pGetExecute(r)
}

/*
P2PsP2pGet Search for Transactions between Payments Accounts

Returns a lit of payment transactions between payments accounts that match the search fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiP2PsP2pGetRequest
*/
func (a *P2PsApiService) P2PsP2pGet(ctx context.Context) ApiP2PsP2pGetRequest {
	return ApiP2PsP2pGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPaymentDetailsOutput
func (a *P2PsApiService) P2PsP2pGetExecute(r ApiP2PsP2pGetRequest) (*GetPaymentDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPaymentDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "P2PsApiService.P2PsP2pGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/p2p"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.transactionComment != nil {
		localVarQueryParams.Add("transactionComment", parameterToString(*r.transactionComment, ""))
	}
	if r.reference != nil {
		localVarQueryParams.Add("reference", parameterToString(*r.reference, ""))
	}
	if r.privateDataValue != nil {
		t := *r.privateDataValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("privateData.value", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("privateData.value", parameterToString(t, "multi"))
		}
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiP2PsP2pPostRequest struct {
	ctx context.Context
	ApiService *P2PsApiService
	authorization *string
	pSUIPAddress *string
	parameters *SendPaymentInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiP2PsP2pPostRequest) Authorization(authorization string) ApiP2PsP2pPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiP2PsP2pPostRequest) PSUIPAddress(pSUIPAddress string) ApiP2PsP2pPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiP2PsP2pPostRequest) Parameters(parameters SendPaymentInput) ApiP2PsP2pPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiP2PsP2pPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiP2PsP2pPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiP2PsP2pPostRequest) PSUUserAgent(pSUUserAgent string) ApiP2PsP2pPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiP2PsP2pPostRequest) AuthorizationFromProvider(authType AuthType) ApiP2PsP2pPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiP2PsP2pPostRequest) AuthorizationBasicFromProvider() ApiP2PsP2pPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiP2PsP2pPostRequest) AuthorizationBearerFromProvider() ApiP2PsP2pPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiP2PsP2pPostRequest) Execute() (*SendPaymentOutput, *http.Response, error) {
	return r.ApiService.P2PsP2pPostExecute(r)
}

/*
P2PsP2pPost Payment between Payment Accounts (P2P)

This call debits Wallet A and credits Wallet B. Payment accounts are internal to Lemonway. You can schedule this payment if you do not want the payment to occure immediately.
The following list corresponds to the payment type specified in the response attribute called:    
  
0 Card  
1 Bank transfert (Money-In)  
3 Bank transfert (Money-Out)  
4 P2P  
13 IDEAL  
14 DirectDebit  
15 Cheque   
19 Multibanco  
20 Payshop  
21 MB WAY    
35 PayPal  
**Important:** The following services have been discontinued: 16 Neosurf, 17 SoFort, 18 PFS Physical Card, 20 Payshop, 22 Polish Instant Transfer, 23 PAGARE, 24 MobilePay,26 WeChat (via PayTend),28 MoneyIn by TPE, 29 Trustly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiP2PsP2pPostRequest
*/
func (a *P2PsApiService) P2PsP2pPost(ctx context.Context) ApiP2PsP2pPostRequest {
	return ApiP2PsP2pPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendPaymentOutput
func (a *P2PsApiService) P2PsP2pPostExecute(r ApiP2PsP2pPostRequest) (*SendPaymentOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendPaymentOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "P2PsApiService.P2PsP2pPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/p2p"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(SendPaymentInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
