/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AccountsUpdateApiService AccountsUpdateApi service
type AccountsUpdateApiService service

type ApiAccountsIndividualPutRequest struct {
	ctx context.Context
	ApiService *AccountsUpdateApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	parameters *UpdateIndividualAccountDetailsInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsIndividualPutRequest) Authorization(authorization string) ApiAccountsIndividualPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsIndividualPutRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsIndividualPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsIndividualPutRequest) Parameters(parameters UpdateIndividualAccountDetailsInput) ApiAccountsIndividualPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsIndividualPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsIndividualPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsIndividualPutRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsIndividualPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsIndividualPutRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsIndividualPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsIndividualPutRequest) AuthorizationBasicFromProvider() ApiAccountsIndividualPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsIndividualPutRequest) AuthorizationBearerFromProvider() ApiAccountsIndividualPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsIndividualPutRequest) Execute() (*UpdateIndividualAccountDetailsOutput, *http.Response, error) {
	return r.ApiService.AccountsIndividualPutExecute(r)
}

/*
AccountsIndividualPut Update Individual Payment Account Data

Enables you to update information related to a client payment account.  
1. The client enters their new data.  
2. The client calls the Lemonway Webservice.  
3. Lemonway records data when it exists.  
4. The application processes Lemonway's response and displays a confirmation message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiAccountsIndividualPutRequest
*/
func (a *AccountsUpdateApiService) AccountsIndividualPut(ctx context.Context, accountid string) ApiAccountsIndividualPutRequest {
	return ApiAccountsIndividualPutRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return UpdateIndividualAccountDetailsOutput
func (a *AccountsUpdateApiService) AccountsIndividualPutExecute(r ApiAccountsIndividualPutRequest) (*UpdateIndividualAccountDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateIndividualAccountDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsUpdateApiService.AccountsIndividualPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/individual/{accountid}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(UpdateIndividualAccountDetailsInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsKycstatusPutRequest struct {
	ctx context.Context
	ApiService *AccountsUpdateApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	parameters *UpdateAccountStatusInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsKycstatusPutRequest) Authorization(authorization string) ApiAccountsKycstatusPutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsKycstatusPutRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsKycstatusPutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsKycstatusPutRequest) Parameters(parameters UpdateAccountStatusInput) ApiAccountsKycstatusPutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsKycstatusPutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsKycstatusPutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsKycstatusPutRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsKycstatusPutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsKycstatusPutRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsKycstatusPutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsKycstatusPutRequest) AuthorizationBasicFromProvider() ApiAccountsKycstatusPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsKycstatusPutRequest) AuthorizationBearerFromProvider() ApiAccountsKycstatusPutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsKycstatusPutRequest) Execute() (*UpdateAccountStatusOutput, *http.Response, error) {
	return r.ApiService.AccountsKycstatusPutExecute(r)
}

/*
AccountsKycstatusPut Update Payment Account Status

Allows certain payment account statuses to be updated. 

- To close an account (status 12), the account must have zero balance.  
- An account status can not be changed to bypass the KYC process. KYC statuses are updated by Lemonway.  
- If an account is closed in status 6 (KYC 2) and you would like to reopen it, you must send a support request to Lemonway.  

You can view all account statues [here.](https://documentation.lemonway.com/reference/wallet-status)  

**Note:** This feature is subject to your contract.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiAccountsKycstatusPutRequest
*/
func (a *AccountsUpdateApiService) AccountsKycstatusPut(ctx context.Context, accountid string) ApiAccountsKycstatusPutRequest {
	return ApiAccountsKycstatusPutRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return UpdateAccountStatusOutput
func (a *AccountsUpdateApiService) AccountsKycstatusPutExecute(r ApiAccountsKycstatusPutRequest) (*UpdateAccountStatusOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAccountStatusOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsUpdateApiService.AccountsKycstatusPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/kycstatus/{accountid}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(UpdateAccountStatusInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsLegalSinglePutRequest struct {
	ctx context.Context
	ApiService *AccountsUpdateApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	parameters *UpdateLegalAccountDetailsInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsLegalSinglePutRequest) Authorization(authorization string) ApiAccountsLegalSinglePutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsLegalSinglePutRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsLegalSinglePutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsLegalSinglePutRequest) Parameters(parameters UpdateLegalAccountDetailsInput) ApiAccountsLegalSinglePutRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsLegalSinglePutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsLegalSinglePutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsLegalSinglePutRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsLegalSinglePutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsLegalSinglePutRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsLegalSinglePutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsLegalSinglePutRequest) AuthorizationBasicFromProvider() ApiAccountsLegalSinglePutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsLegalSinglePutRequest) AuthorizationBearerFromProvider() ApiAccountsLegalSinglePutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsLegalSinglePutRequest) Execute() (*UpdateLegalAccountDetailsOutput, *http.Response, error) {
	return r.ApiService.AccountsLegalSinglePutExecute(r)
}

/*
AccountsLegalSinglePut Update Legal Payment Account Data

This method enables you to update information relating to a **legal** client payment account.  
1. The client enters their new data.  
2. The client calls the Lemonway Webservice.  
3. Lemonway records data when it exists.  
4. The application processes Lemonway's response and displays a confirmation message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiAccountsLegalSinglePutRequest
*/
func (a *AccountsUpdateApiService) AccountsLegalSinglePut(ctx context.Context, accountid string) ApiAccountsLegalSinglePutRequest {
	return ApiAccountsLegalSinglePutRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return UpdateLegalAccountDetailsOutput
func (a *AccountsUpdateApiService) AccountsLegalSinglePutExecute(r ApiAccountsLegalSinglePutRequest) (*UpdateLegalAccountDetailsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateLegalAccountDetailsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsUpdateApiService.AccountsLegalSinglePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/legal/{accountid}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(UpdateLegalAccountDetailsInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
