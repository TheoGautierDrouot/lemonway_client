/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MoneyInsPayByLinkApiService MoneyInsPayByLinkApi service
type MoneyInsPayByLinkApiService service

type ApiMoneyInsCardPaymentFormPostRequest struct {
	ctx context.Context
	ApiService *MoneyInsPayByLinkApiService
	authorization *string
	pSUIPAddress *string
	parameters *CreatePaymentFormInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsCardPaymentFormPostRequest) Authorization(authorization string) ApiMoneyInsCardPaymentFormPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsCardPaymentFormPostRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsCardPaymentFormPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiMoneyInsCardPaymentFormPostRequest) Parameters(parameters CreatePaymentFormInput) ApiMoneyInsCardPaymentFormPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsCardPaymentFormPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsCardPaymentFormPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsCardPaymentFormPostRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsCardPaymentFormPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsCardPaymentFormPostRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsCardPaymentFormPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardPaymentFormPostRequest) AuthorizationBasicFromProvider() ApiMoneyInsCardPaymentFormPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsCardPaymentFormPostRequest) AuthorizationBearerFromProvider() ApiMoneyInsCardPaymentFormPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsCardPaymentFormPostRequest) Execute() (*CreatePaymentFormOutput, *http.Response, error) {
	return r.ApiService.MoneyInsCardPaymentFormPostExecute(r)
}

/*
MoneyInsCardPaymentFormPost Create Payment Form (Pay by Link)

 Accept payments by an SMS, email, or document.   
 Create a form that permits your customers to make card payments by link.     
 
- Payment forms are generated and managed by Lemonway.  
- Payment forms are publicly accessible, making it possible for anyone to pay with a valid link.    
- Payment by bank card is only supported.  

Payment Scenerios:  
1. **Benificary Wallet `walletReceiver` not specified**  
You only specify `walletPayer` and not `walletReceiver` in the body parameters.  
They make a card payment and funds are transfered to the `walletPayer` (a designated wallet)

2. **Payer and Benificary Wallet defined**  

3. **Benificary pecified**  

 **Note:** Deferred payment is not supported.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoneyInsCardPaymentFormPostRequest
*/
func (a *MoneyInsPayByLinkApiService) MoneyInsCardPaymentFormPost(ctx context.Context) ApiMoneyInsCardPaymentFormPostRequest {
	return ApiMoneyInsCardPaymentFormPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePaymentFormOutput
func (a *MoneyInsPayByLinkApiService) MoneyInsCardPaymentFormPostExecute(r ApiMoneyInsCardPaymentFormPostRequest) (*CreatePaymentFormOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePaymentFormOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsPayByLinkApiService.MoneyInsCardPaymentFormPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/card/paymentform"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(CreatePaymentFormInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsPaymentFormCompletedGetRequest struct {
	ctx context.Context
	ApiService *MoneyInsPayByLinkApiService
	formid string
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsPaymentFormCompletedGetRequest) Authorization(authorization string) ApiMoneyInsPaymentFormCompletedGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsPaymentFormCompletedGetRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsPaymentFormCompletedGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsPaymentFormCompletedGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsPaymentFormCompletedGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsPaymentFormCompletedGetRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsPaymentFormCompletedGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsPaymentFormCompletedGetRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsPaymentFormCompletedGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsPaymentFormCompletedGetRequest) AuthorizationBasicFromProvider() ApiMoneyInsPaymentFormCompletedGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsPaymentFormCompletedGetRequest) AuthorizationBearerFromProvider() ApiMoneyInsPaymentFormCompletedGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsPaymentFormCompletedGetRequest) Execute() (*GetCompletedPaymentFormOutput, *http.Response, error) {
	return r.ApiService.MoneyInsPaymentFormCompletedGetExecute(r)
}

/*
MoneyInsPaymentFormCompletedGet Get Details of a Completed Payment Form

This method lets you to retreive the status of a <b>completed (or filled) payment form</b><br />
Scenario
<ul><li>Using the POST /moneyins/card/paymentform method, you have generated a re-usable Payment Form (with the form Id is for example 579c7def4bb0411da294d9b57c2c1323)</li><li>Some clients filled the form and make payment.</li><li>Each time a client completes the form and click on the <b>Accept and Pay</b> button, Lemonway will store the completed form and generate a new id for it, for example 7e98be392a5e45f6bc357a9ab8c623d2</li><li>The initial status of the <b>completed form</b> is pending. When client finish the payment process, it will switch to PAID. It could also switch to CANCEL or ERROR.</li><li>In this example, the completed form 7e98.. was created from the parent form 579c..The form 579c.. is reusable, which means it can be completed several time by different clients, so it could have many completed version.This function allows you to retreive the status of a the filled form via its id (7e98..).</li></ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param formid
 @return ApiMoneyInsPaymentFormCompletedGetRequest
*/
func (a *MoneyInsPayByLinkApiService) MoneyInsPaymentFormCompletedGet(ctx context.Context, formid string) ApiMoneyInsPaymentFormCompletedGetRequest {
	return ApiMoneyInsPaymentFormCompletedGetRequest{
		ApiService: a,
		ctx: ctx,
		formid: formid,
	}
}

// Execute executes the request
//  @return GetCompletedPaymentFormOutput
func (a *MoneyInsPayByLinkApiService) MoneyInsPaymentFormCompletedGetExecute(r ApiMoneyInsPaymentFormCompletedGetRequest) (*GetCompletedPaymentFormOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCompletedPaymentFormOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsPayByLinkApiService.MoneyInsPaymentFormCompletedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/paymentform/{formid}/completed"
	localVarPath = strings.Replace(localVarPath, "{"+"formid"+"}", url.PathEscape(parameterToString(r.formid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoneyInsPaymentFormDisablePutRequest struct {
	ctx context.Context
	ApiService *MoneyInsPayByLinkApiService
	formid string
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiMoneyInsPaymentFormDisablePutRequest) Authorization(authorization string) ApiMoneyInsPaymentFormDisablePutRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiMoneyInsPaymentFormDisablePutRequest) PSUIPAddress(pSUIPAddress string) ApiMoneyInsPaymentFormDisablePutRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiMoneyInsPaymentFormDisablePutRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiMoneyInsPaymentFormDisablePutRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiMoneyInsPaymentFormDisablePutRequest) PSUUserAgent(pSUUserAgent string) ApiMoneyInsPaymentFormDisablePutRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiMoneyInsPaymentFormDisablePutRequest) AuthorizationFromProvider(authType AuthType) ApiMoneyInsPaymentFormDisablePutRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsPaymentFormDisablePutRequest) AuthorizationBasicFromProvider() ApiMoneyInsPaymentFormDisablePutRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiMoneyInsPaymentFormDisablePutRequest) AuthorizationBearerFromProvider() ApiMoneyInsPaymentFormDisablePutRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiMoneyInsPaymentFormDisablePutRequest) Execute() (*DisablePaymentFormOutput, *http.Response, error) {
	return r.ApiService.MoneyInsPaymentFormDisablePutExecute(r)
}

/*
MoneyInsPaymentFormDisablePut Disable a Payment Form

Disable a payment form created by CreatePaymentForm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param formid
 @return ApiMoneyInsPaymentFormDisablePutRequest
*/
func (a *MoneyInsPayByLinkApiService) MoneyInsPaymentFormDisablePut(ctx context.Context, formid string) ApiMoneyInsPaymentFormDisablePutRequest {
	return ApiMoneyInsPaymentFormDisablePutRequest{
		ApiService: a,
		ctx: ctx,
		formid: formid,
	}
}

// Execute executes the request
//  @return DisablePaymentFormOutput
func (a *MoneyInsPayByLinkApiService) MoneyInsPaymentFormDisablePutExecute(r ApiMoneyInsPaymentFormDisablePutRequest) (*DisablePaymentFormOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisablePaymentFormOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoneyInsPayByLinkApiService.MoneyInsPaymentFormDisablePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/moneyins/paymentform/{formid}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"formid"+"}", url.PathEscape(parameterToString(r.formid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, &GenericOpenAPIError{
                    body: nil,
                    error: err.Error(),
                    model: localAdditionalValues,
                }
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
